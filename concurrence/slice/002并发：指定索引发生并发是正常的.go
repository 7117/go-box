package main

import (
	"fmt"
	"sync"
)

func concurrentAppendSliceForceIndex() {
	sl := make([]int, 100)
	wg := sync.WaitGroup{}
	for index := 0; index < 100; index++ {
		wg.Add(1)
		go func(index int) {
			sl[index] = index
			wg.Done()
		}(index)
	}
	wg.Wait()
	fmt.Println(sl)
	fmt.Printf("final len(sl)=%d cap(sl)=%d\n", len(sl), cap(sl))
}
func main() {
	concurrentAppendSliceForceIndex()
	/*第一次运行代码后，输出：[0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 7
	9 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99]
	final len(sl)=100 cap(sl)=100*/
	/*第一次运行代码后，输出：[0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 7
	9 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99]
	final len(sl)=100 cap(sl)=100*/
	/*第一次运行代码后，输出：[0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 7
	9 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99]
	final len(sl)=100 cap(sl)=100*/
	//这个发现了指定索引的时候是没有问题的
	//并发写入的时候，多个协程作用于一个底层的数组，底层数组变化了的话，会导致切片变化，之前的写入就失效了，所以并发写入的时候是不安全的。

	//所以当别人问你slice支持并发时，你就可以这样回答它：
	//当指定索引使用切片时，切片是支持并发读写索引区的数据的，但是索引区的数据在并发时会被覆盖的，之前修改的就失效了，白修改了。
	//当不指定索引切片时，并且切片动态扩容时，并发场景下扩容会被覆盖，所以切片是不支持并发的～

	//	当扩容的时候，会导致底层数组变化，然后就会产生脏数据了
	//	使用append的时候，会发生数据覆盖的情况
}
